<!DOCTYPE html>
<html>
<head>
<script type="text/javascript" language="javascript/jsa">
     function power(input1,input2){
         var r = 1;
         for(var i=0; i<input2; i++)
            r*=input1;
         return r;
      }
    
     function mult_as_add(input1,input2){
         var r = 0;
         for(var i=0; i<input2; i++){
            r+=input1;
         console.log(r);
         }
      }
 
      function tt(
      a,
      b
      ){
      console.log(a+' '
      +b)
        }
                  
   function testee(
      b
      ){
     console.log(this);
      console.log(a+' '
      +b)
        }
                  
</script>
<script type="text/javascript">
               
     
               
      
Asynchronizer = {
   //functionRegistry stores the async data for all functions processed.
   //It is an array to assure quick lookup.
   //Object properties:
   //               {key : top_caller1_caller2...callerN_functionName,
   //               substeps : [functionized loops (named with above + _i)],
   //               ipa : [numbers - as many as above]
   //               }
   functionRegistry : [],
   testDeclaration : function(line){
      return line.search(/var\s+.+?=.+/) !== -1;
   },
   hasTimer : true,
   getDeclarations : function(line){
      var vars = line.match(/var\s+.+?=/g);
      var size = vars.length, v, i ,j, size2;
      var declarations = '';
      for(i=0; i<size; i++){
         v = vars[i];
         //Clear the var declaration, split along possible delimiters, extract LHS, concat.
         v = v.replace(/var\s+/g,'');
         v = v.split(/,|;/);
         var size2 = v.length;
         for(j=0; j<size2; j++){
            declarations += ','+v[j].split('=')[0];
         }
      }
      return declarations.substring(1)+';'; //remove leading comma
   },
   thefunc : null,
   activeCall : null, //holds the current timeout. (This will probably need to be an array of a more complex structure)
   //Thank you, D.C. : http://www.crockford.com/javascript/inheritance.html
   inherit : function (child,parent) {
      var d = {}, p = (child.prototype = new parent());
      child.uber = function uber(name) {
      if (!(name in d)) {
         d[name] = 0;
      }
      var f, r, t = d[name], v = parent.prototype;
      if (t) {
         while (t) {
           v = v.constructor.prototype;
           t -= 1;
         }
         f = v[name];
      } else {
         f = p[name];
         if (f == child[name]) {
           f = v[name];
         }
      }
      d[name] += 1;
      r = f.apply(child, Array.prototype.slice.apply(arguments, [1]));
      d[name] -= 1;
      return r;
      };
      return child;
   },
   initTimestamp : new Date().getTime(), // For scope chain hashing function names
};
 
      function process(inputPointer,input,token,activeScope){
         var result = tokenize(token);
         if(result != null){
            switch(result){
               case 'function':
     var func = standardize(token,input,'function');
     activeScope.contents.push(func.data);
              func.data.outer = activeScope;
     scan(func.data.content,func.data); //Recurse
     inputPointer = func.newPos;
     //delete func.data.content;
     break;
               case 'forLoop':
     var forLoop = standardize(token,input,'forLoop');
              forLoop.data.outer = activeScope;
     activeScope.contents.push(forLoop.data);
     scan(forLoop.data.content,forLoop.data); //Recurse
     inputPointer = forLoop.newPos;
     //delete forLoop.data.content;
     break;
               case 'plainline': //This is the default. Must be last case or else will match most prior tokens
     //Ignore trim-worthy things
     if(!isBlank(token)){
        var plainline = standardize(token,input,'plainline');
        activeScope.contents.push(plainline.data);
        inputPointer = plainline.newPos;
     }
     break;
            }
            //Position in the scan loop necessitates storing part of the raw remainder for subsequent scanning. Refactor later.
            token = input[inputPointer];
         }
 
         return {iPointer : inputPointer, raw : token};
      }
               
   function performScan(input){
      var topLevel = {contents : [], type : 'globalObj'};
      scan(input,topLevel);
      return topLevel.contents;
   }
               
      function scan(input,activeScope){
         var scanner = '';
         var token = '';
         var updated;
         var size = input.length;
         for(var inputPointer=0; inputPointer<size; inputPointer++){
            token += input[inputPointer];
            updated = process(inputPointer,input,token,activeScope);
            inputPointer = updated.iPointer;
            token = updated.raw;
         }
         //Finish the remaining token. Should be plainline.
         process(inputPointer,input,token,activeScope);
         return activeScope;
      }
 
      function isBlank(t){
         return t.replace(/\s/g,'').length == 0;
      }
 
      function tokenize(input){
         var t = tokens;
         var size = t.length;
         for(var i=0; i<size; i++){
            if(t[i].rule.test(input))
               return (t[i].name);
         }
         return null;
      }
 
 
    function asynchronize(input){
               
      if(input.type != 'Func')
      {
         throw {message: 'asynchronize called can only be called on a Func object', problem: input}
      }
      //Builder
      var funcBody = '';
      var func_step = 0; //Keeps track of topological ordering.
                  
      //Hold data for function. This object will be serialized after creation and then parsed in the script content re-write.
      var AsyncData = {substeps : [], ipa_list: []};
                  
      //TODO: set this dynamically.
      //Determine scope chain and function name for library global storage hash.
      var scope_chain_hash = input.getScopeChainHash();
      AsyncData.key = scope_chain_hash;
                  
      //Why do it this way? If keep as is, we can deal with functions by assignment as well: will need separate handling
      //in functionRegistry assignment, however.
                  
      //Extract signature, without name, and collect parameters for new function construction.
      //var s_index = input.sig.search('function') + 8;
      //var sig_sub = input.sig.substring(s_index);
      //var sig_remainder = sig_sub.match(/\s*\(.*\)\s*/)[0];
      var sig_remainder = input.sig;
                  
      //funcBody += 'function '+sig_remainder+'\n{\n';
      funcBody += sig_remainder+'\n{\n';
                  
                  
      /* Cannot use this for Function constructor because of closure issue. See:
      https://developer.mozilla.org/en/JavaScript/Reference/Global_Objects/Function
                  
      sig_remainder = sig_remainder.substr(1,sig_remainder.length-2);
      //First arguments for builder. Will need to be split into parameters.
      var args = sig_remainder.split(',');
      */
                  
      //Asynchronize the function
      //This is kept internal for closure access to vars above.
      var handle_contents = function(wrapper)
      {
         var func_innards = '';
         var innerFuncDefs = '';
         var declarations = '';
         var indent = '\t';
         var funcDataPosition, async_data;
         var size = wrapper.contents.length;
         for(var i=0; i<size; i++){
            var element = wrapper.contents[i];
            switch(element.type){
               case 'Plainline' :
                  func_innards += indent+element.content;
                  break;
               case 'ForLoop' :
                  var seq = ++func_step;
                  //Close off sequential plain line statements from prior post-forloop return if there are more than 1. in the function
                  if(seq > 1){
                     func_innards += '\t}';
                     indent = '\t';
                  }
                  //AsyncData.sub_functions.length may be extended in loop_to_func recursion, but this is correct for nested -> sequential.
                  var innerFunc = loop_to_func(element,scope_chain_hash,seq,scope_chain_hash+'_ipa');
                  innerFuncDefs = indent+innerFunc.f_func+'\n';
                  //Push the outer function into the registry. It only needs to keep track of its substeps (in first release, at any rate).
                  funcDataPosition = Asynchronizer.functionRegistry.length;
                  async_data = {finishedStep: 0};
                  Asynchronizer.functionRegistry.push(async_data);
                  declarations += indent+innerFunc.var_decl;
                  //func_innards += '{\n'+innards+'\n}';
                  func_innards += indent+innerFunc.f_call+'\n';
                  //Setup catch for sequential code that followed the loop. func_step should be topologically incremented to the ending spot
                  func_innards += indent+'if(Asynchronizer.functionRegistry.finishedStep == '+func_step+'){\n';
                  //Reset for next call
                  func_innards += indent+'\t'+'Asynchronizer.functionRegistry.finishedStep = '+0+';\n';
                  indent = '\t\t';
                  break;
               case 'Func' :
                  break;
            }
         }
         //Close off sequential statements after last forLoop conversion
         if(seq > 0)
            func_innards += '\t}\n';
         //declarations = (declarations.replace(/\t/g,'') === '') ? '' : declarations+';\n';
         funcBody += innerFuncDefs + declarations + func_innards;
         funcBody += '}';
      }
                  
      //Helper for prior function: structured as function to benefit from recursion for inner loops
      var loop_to_func = function (forloop,scope_chain_hash,seq)
      {
         //No special hashing needed to retrieve the info from the main functionRegistry: just hard code it.
         var funcDataPosition = Asynchronizer.functionRegistry.length;
         var async_data = {lastCalled: 0, ipa: 0, maxLockTime: 200, converged: false, freshCall: true};
         Asynchronizer.functionRegistry.push(async_data);
         var f_data_var = scope_chain_hash+'_'+seq+'_data'; //helper object's name within the associated function.
         //Name for funced loop: will follow depth-first
         var func_name = scope_chain_hash+'_'+seq;
         var f_call; //Plainline call to the function.
         var f_func; //function created from forLoop body.
                     
         //For tuning
         var timer_var_name = scope_chain_hash+'_'+seq+'_timer';
                     
         //For formatting: (maybe make this optional)
         var indent = '';
         for(var i=0; i<seq+1; i++)
            indent += '\t';
         //will be needed for the outer function to assure closure across other functionized loops at the same function scope.
         var f_declarations = '';
         var sig = forloop.sig;
         //Parse the parts of the loop
         var start = sig.indexOf('for('), end = sig.lastIndexOf(')');
         sig = sig.substring(start+4,end);
         var statements = sig.split(';');
         //Capture declarations made in the init statement: variable decl. must be done in the outer context.
         if(Asynchronizer.testDeclaration(statements[0])){
            f_declarations += Asynchronizer.getDeclarations(statements[0]);
         }
         //Sig
         f_func = 'function '+func_name+'('+f_data_var+')\n';
         //Opening: go back one tab
         f_func += indent.substring(1)+'{\n';
         //Timing caliper or ipa set.
         var curr_ipa_var = scope_chain_hash+'_'+seq+'_ipa_curr';
         var ipa_var_name = scope_chain_hash+'_'+seq+'_ipa';
         //Set init conditions
         f_func += indent+'if('+f_data_var+'.converged === false)\n';
         f_func += indent+'{\n';
         if(Asynchronizer.hasTimer){
            f_func += indent+'\tvar '+timer_var_name+' = new Date().getTime();\n';
            f_func += indent+'\tif('+timer_var_name+' - '+f_data_var+'.lastCalled > '+async_data.maxLockTime+')\n';
            f_func += indent+'\t'+f_data_var+'.lastCalled = '+timer_var_name+';\n';
         }
         f_func += indent+'}\n';
         f_func += indent+'else\n';
         f_func += indent+'{\n';
         f_func += indent+'\t'+ipa_var_name+' = '+f_data_var+'.ipa;\n';
         f_func += indent+'}\n';
         //Check whether to set initial condition on this entry
         f_func += indent+'if('+f_data_var+'.freshCall === true)\n';
         f_func += indent+'{\n';
         f_func += indent+'\t'+f_data_var+'.freshCall = false;\n';
         f_func += indent+'\t'+(statements[0])+';\n';
         f_func += indent+'}\n';
         //Reconstruction of the forLoop: user submitted condition && iterations per async within limit.
                     
         f_func += indent+'for('+curr_ipa_var+' = 0;'+(statements[1])+' && '+(curr_ipa_var+' < '+ipa_var_name)+'; '+statements[2]+', '+curr_ipa_var+'++)\n';
         f_func += indent+'{\n';
         var size = forloop.contents.length;
         for(var l = 0; l < size; l++){
            var line = forloop.contents[l];
            if(line.type == 'Plainline'){
               f_func += indent+'\t'+line.content;
               //variable decl. must be done in the outer context.
               if(Asynchronizer.testDeclaration(line.content)){
                  f_declarations += Asynchronizer.getDeclarations(line.content);
               }
            }
            else if(line.type == 'ForLoop'){
               var position = ++func_step;
               //Recursive call.
               var innerFunc = loop_to_func(line,scope_chain_hash,position,ipa_var_name);
               AsyncData.sub_functions.push(innerFunc.f_func);
               AsyncData.ipa_list.push(null)
               f_func += '\t'+innerFunc.f_call;
               //f_func += '\n}';
            }
         }
         //Clean up declarations if it's more than just tabs.
         if(f_declarations.search(/[^\t]/) !== -1) f_declarations = 'var '+ f_declarations + '\n';
         f_func += indent+'}\n';
         //Check condition
         f_func += indent+'if('+(statements[1])+')\n';
         f_func += indent+'{\n';
         f_func += indent+'\tAsynchronizer.activeCall = setTimeout(function(){'+func_name+'('+f_data_var+');},'+timer_var_name+')\n';
         f_func += indent+'\treturn;\n'
         f_func += indent+'}\n';
         //Closing: go back one tab
         f_func += indent.substring(1)+'}';
         //For caller:
         f_call = func_name+'();';
         return {'f_name' : func_name, 'f_call' : f_call, 'f_func' : f_func, 'var_decl' : f_declarations};
      }
                  
      handle_contents(input);
                  
       
      console.log(funcBody);
                  
                  
      //Storing in the registry will be done in the caller.
      return '\n'+funcBody;
    }
    
               
 
   var forLoop_regex = /^\s*for\s*\($/;  //.*;.*;.*\)
   var function_regex = /^\s*function\s*\S+\($/; //(((.*,)+(.*){1})|((.*)))\)
   //Default - will capture all valid JS statements (and some expressions).
   var plainline_regex = /^\s*.*(;|\n){1}$/;
     
      
      
      
      
      
   var tokens = [
      {name: 'forLoop', rule: forLoop_regex},
      {name: 'function', rule: function_regex},
      {name: 'plainline', rule: plainline_regex}
   ];
 
   function standardize(token,input,type){
      var ret, callerIteratorPosition=0;
      switch(type){
      case 'function':
         ret = new Func();
         var start = input.indexOf(token);
         //Get signature
         var paramListLevel = 1, iter = start + token.length;
         while(paramListLevel != 0){
            if(iter > input.length)
               throw {message: "Function parameter list not well formed", problem: input}
            iter++;
            if(input.charAt(iter) == ')')
               paramListLevel--;
            else if(input.charAt(iter) == '(')
               paramListLevel++;
         }
         callerIteratorPosition += iter;
         //Clean up sig
         ret.sig = input.substring(start,iter+1).replace(/\s{2,}/g,'')//.replace(/\n{2,}/g,'\n');
         //Needed? Just extract sig more creatively.
         //Determine name: clear 'function' and params. Will need to consider function as an assignment also if that is all \s*
         //ret.name = ret.sig.substring(ret.sig.match(/function\s*/)[0].length,ret.sig.search(/\(/));
         //Find body beginning
         var rest = input.substring(iter);
         iter = rest.indexOf('{');
         var bodyBeginPos = iter+1;
         level = 1;
         while(level != 0){
            if(iter > rest.length)
               throw {message: "Function body not well formed", problem: input}
            iter++;
            if(rest.charAt(iter) == '}')
               level--;
            else if(rest.charAt(iter) == '{')
               level++;
         }
         callerIteratorPosition += iter+1; //+1 for opening bracket
         ret.content = rest.substring(bodyBeginPos,iter).replace(/\s{2,}/g,'\n'); //.replace(/\n{2,}/g,' ')
         break;
      case 'forLoop':
         ret = new ForLoop();
         var start = input.indexOf(token);
         //Get signature.
         var paramListLevel = 1, iter = start + token.length, semicols = 0;
         while(paramListLevel != 0){
            if(iter == input.length && semicols != 2)
               throw {message: "For loop parameter list not well formed", problem: input}
               iter++;
            switch(input.charAt(iter)){
               case ')': paramListLevel--; break;
               case '(': paramListLevel++; break;
               case ';': semicols++; break;
            }
         }
         callerIteratorPosition += iter;
         ret.sig = input.substring(start,iter+1).replace(/\s{2,}/g,' ');
         //Determine whether braced or not, and fix if not
         var rest = input.substring(iter+2);
         if(rest.indexOf('{') == -1 || rest.indexOf('{') > rest.search(/\S/)){
           var statement_end = rest.search(/[\n;]/);
           rest = '{'+rest.substring(0,statement_end+1)+'}';
         }
         //Find body beginning
         iter = 0;
         var bodyBeginPos = iter+1;
         level = 1;
         while(level != 0){
         if(iter > rest.length)
            throw {message: "For loop body not well formed", problem: input}
         iter++;
         if(rest.charAt(iter) == '}')
            level--;
         else if(rest.charAt(iter) == '{')
            level++;
         }
         callerIteratorPosition += iter+1; //+1 for expr. terminator?
         ret.content = rest.substring(bodyBeginPos,iter).replace(/\s{2,}/g,'\n');
         break;
      case 'plainline':
         ret = new Plainline();
         /* Taking this out because JS finds the statement terminator better on its own.
         var semicolon = token.charAt(token.length-1) == ';' ? '' : ';'
         ret.content = token + semicolon;
         */
         if(token.charAt(0) == '\n')
            token = token.substring(1);
         if(token.charAt(token.length-1) != '\n')
            token += '\n';
         ret.content = token;
         ret.sig = '(plainline)'
         var callerIteratorPosition = input.indexOf(token) + token.length;
         break;
      }
      return  {data: ret, newPos: callerIteratorPosition};
   }
 
      //Classes. Expression is abstract base.
   function Expression(sig,content)
   {
      this.sig = (typeof sig != 'string') ? '' : sig;
      this.type = 'Expression';
      this.content = (typeof content != 'string') ? '' : content
   }
 
   function ForLoop(sig,content)
   {
      this.contents = []; //Will replace "content" when filled.
      this.type = 'ForLoop'
   }
   Asynchronizer.inherit(ForLoop,Expression);
 
   function Func(sig,contents,outer)
   {
      this.contents = []; //Will replace "content" when filled.
      this.type = 'Func';
      this.name = '';
      this.outer = (outer !== undefined && outer.prototype === Func) ? outer : null;
      this.getScopeChainHash = function(){
         var hash = '';
         var scope = this.outer;
         while(scope.type !== 'globalObj'){
            hash = this.outer.name+'_'+help;
            scope = scope.outer;
         }
         return hash + 'top_'+Asynchronizer.initTimestamp;
      }
   }
   Asynchronizer.inherit(Func,Expression);
               
 
   function Plainline(content)
   {
      this.type = 'Plainline';
   }
    Asynchronizer.inherit(Plainline,Expression);
 
 
 
   /*
   var input = power
   scan(input.toString(),output);
   console.log(output);
    var output2 = [];
    scan(tt.toString(),output2)
    console.log(output2);
   var testme = output2[0];
   var test = asynchronize(scan(testee.toString(),[])[0]);
   */
               
   function init(){
      var i,j,scriptContent;
      var scripts = document.getElementsByTagName('script');
      var async_set = [];
      var size = scripts.length;
      for(i=0; i<size; i++){
         if(scripts[i].getAttribute('language') == 'javascript/jsa')
            async_set.push(scripts[i]);
      }
      size = async_set.length;
      for(i=0; i<size; i++){
         var script = async_set[i];
         var output = performScan(async_set[i].innerText);
         var itemnum = output.length;
         scriptContent = '';
         for(j=0; j<itemnum; j++){
            if(output[j].__proto__ == Func.prototype)
               scriptContent += asynchronize(output[j]);
            else
               scriptContent += output[j].toString();
         }
         script.innerHTML = scriptContent;
      }
   }
               
   function page(){
      document.getElementById('user').addEventListener('click',function(){
         var val = parseInt(document.getElementById('number').value);
         document.getElementById('number').value = ++val;
      });
      init();
   }
               
</script>
 
</head>
<body onload="page()">
   <input type="button" value="Click Me" id="user"/>
   <input id="number" value="0"/>
</body>
</html>